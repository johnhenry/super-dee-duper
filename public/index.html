<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Super Dee Duper - Duplicate File Manager</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f8f8;
        --text-primary: #000000;
        --text-secondary: #666666;
        --border-color: #e0e0e0;
        --accent-color: #7c3aed;
        --delete-color: #ef4444;
        --success-color: #10b981;
        --warning-color: #f59e0b;
      }

      [data-theme="dark"] {
        --bg-primary: #18181b;
        --bg-secondary: #27272a;
        --text-primary: #ffffff;
        --text-secondary: #a1a1aa;
        --border-color: #3f3f46;
        --accent-color: #8b5cf6;
        --delete-color: #f87171;
        --success-color: #34d399;
        --warning-color: #fbbf24;
      }

      body {
        font-family: "Segoe UI", system-ui, sans-serif;
        margin: 0;
        padding: 0;
        background: var(--bg-primary);
        color: var(--text-primary);
        transition: background-color 0.3s, color 0.3s;
        line-height: 1.5;
      }

      .header-container {
        position: sticky;
        top: 0;
        background: var(--bg-primary);
        z-index: 100;
        border-bottom: 1px solid var(--border-color);
      }

      .header-content {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      .header-content.collapsed .stats,
      .header-content.collapsed .filters,
      .header-content.collapsed .top-actions,
      .header-content.collapsed .scan-info {
        display: none;
      }
      .scan-info {
        display: none;
      }

      .scan-info.show {
        display: block;
      }

      .header-content.collapsed .scan-info.show {
        display: none;
      }

      .collapse-header-btn {
        background: none;
        border: 1px solid var(--border-color);
        padding: 8px;
        cursor: pointer;
        color: var(--text-primary);
        margin-right: 10px;
      }
      .stats {
        background: var(--bg-secondary);
        padding: 10px;
        margin-bottom: 20px;
        border: 1px solid var(--border-color);
        display: flex;
        gap: 20px;
      }

      .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .stat-value {
        font-size: 24px;
        font-weight: 600;
        color: var(--accent-color);
      }

      .stat-label {
        font-size: 14px;
        color: var(--text-secondary);
      }

      h1 {
        font-size: 28px;
        font-weight: 600;
        margin: 0;
      }

      .controls {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .theme-toggle {
        background: none;
        border: 1px solid var(--border-color);
        padding: 8px;
        cursor: pointer;
        color: var(--text-primary);
      }
      .main-content {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        padding-bottom: 70px;
      }

      .group {
        background: var(--bg-secondary);
        margin: 20px 0;
        border: 1px solid var(--border-color);
      }

      .group-header {
        display: flex;
        align-items: center;
        padding: 15px;
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
        border-bottom: 1px solid var(--border-color);
        background: var(--accent-color);
        color: white;
      }

      .group-header h3 {
        margin: 0;
        flex-grow: 1;
        font-size: 18px;
        font-weight: 600;
      }

      .group-content {
        padding: 0;
      }

      .file {
        display: flex;
        align-items: center;
        padding: 10px;
        background: var(--bg-primary);
        border-bottom: 1px solid var(--border-color);
      }

      .file:last-child {
        border-bottom: none;
      }

      .file-select {
        margin-right: 15px;
      }

      .file-info {
        flex-grow: 1;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .file-icon {
        font-size: 20px;
        width: 24px;
        text-align: center;
      }

      .file-details {
        flex-grow: 1;
      }

      .file-path {
        word-break: break-all;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .file-meta {
        font-size: 14px;
        color: var(--text-secondary);
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
      }
      .actions {
        display: flex;
        gap: 5px;
        align-items: center;
      }

      button {
        padding: 8px 16px;
        background: var(--accent-color);
        color: white;
        border: none;
        cursor: pointer;
        transition: all 0.2s;
        font-weight: 500;
        font-size: 14px;
        height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      button:hover {
        filter: brightness(110%);
      }

      button:active {
        filter: brightness(90%);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .delete {
        background: var(--delete-color);
      }

      .download {
        background: var(--success-color);
      }

      .preview-btn {
        background: var(--warning-color);
      }

      input[type="text"] {
        padding: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        height: 32px;
        font-size: 14px;
        box-sizing: border-box;
      }

      .rename-container {
        display: flex;
        gap: 5px;
      }

      .rename-container input {
        width: 120px;
      }

      .top-actions {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .filters {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      .filter-input {
        flex: 1;
        min-width: 200px;
        height: 32px;
      }
      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .filter-label {
        color: var(--text-secondary);
        font-size: 14px;
        font-weight: 500;
      }

      select {
        padding: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        cursor: pointer;
        height: 32px;
        font-size: 14px;
      }

      .preview-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        padding: 20px;
      }

      .preview-content {
        max-width: 90%;
        max-height: 90%;
        margin: 20px auto;
        background: var(--bg-primary);
        padding: 20px;
        overflow: auto;
      }
      .preview-image {
        max-width: 100%;
        height: auto;
      }

      .preview-text {
        white-space: pre-wrap;
        font-family: "Cascadia Code", Consolas, monospace;
      }

      .close-preview {
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
      }

      .collapse-indicator {
        margin-right: 10px;
        transition: transform 0.3s;
        color: white;
      }

      .collapsed .collapse-indicator {
        transform: rotate(-90deg);
      }

      .collapsed .group-content {
        display: none;
      }

      .batch-rename {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-top: 10px;
      }

      .media-preview {
        max-width: 100%;
        max-height: 70vh;
        margin: 0 auto;
        display: block;
      }
      .preview-audio {
        width: 100%;
        margin: 20px 0;
      }

      .preview-video {
        max-width: 100%;
        max-height: 70vh;
        margin: 0 auto;
        display: block;
      }

      .preview-iframe {
        width: 100%;
        height: 70vh;
        border: none;
      }

      .scan-info {
        background: var(--bg-secondary);
        padding: 15px;
        margin-bottom: 20px;
        border: 1px solid var(--border-color);
      }

      .scan-info-item {
        margin: 5px 0;
        color: var(--text-secondary);
      }

      .scan-info-value {
        color: var(--text-primary);
        font-weight: 500;
      }

      .filter-group select {
        min-width: 150px;
      }

      .auto-select-group {
        margin-left: auto;
        display: flex;
        gap: 10px;
        align-items: flex-end;
      }

      .delete-options {
        display: none;
      }

      .file-actions {
        display: flex;
        gap: 5px;
        margin-left: auto;
      }

      .individual-delete {
        padding: 4px 8px;
        font-size: 12px;
      }

      .footer {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg-primary);
        border-top: 1px solid var(--border-color);
        padding: 15px 20px;
        display: flex;
        justify-content: center;
        gap: 10px;
        z-index: 100;
      }

      @media (max-width: 768px) {
        .actions {
          flex-wrap: wrap;
        }

        .file {
          flex-direction: column;
          gap: 10px;
        }

        .file-select {
          align-self: flex-start;
        }

        .actions {
          width: 100%;
          justify-content: flex-end;
        }

        .rename-container {
          width: 100%;
        }

        .rename-container input {
          flex-grow: 1;
          width: auto;
        }
      }
    </style>
    <script type="module">
      import { pipeline } from "https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.0.2";
      window.pipeline = pipeline;
    </script>
  </head>
  <body>
    <div class="header-container">
      <div class="header-content">
        <div class="header">
          <h1>Super Dee Duper : Duplicate File Manager</h1>
          <div class="controls">
            <button
              class="collapse-header-btn"
              onclick="toggleHeader()"
              aria-label="Toggle header"
            >
              â–¼
            </button>
            <button
              class="theme-toggle"
              onclick="toggleTheme()"
              aria-label="Toggle dark mode"
            >
              ðŸŒ“
            </button>
          </div>
        </div>
        <div id="scanInfo" class="scan-info">
          <!-- Populated by JavaScript -->
        </div>

        <div class="stats" id="stats">
          <div class="stat-item">
            <div class="stat-value" id="totalGroups">0</div>
            <div class="stat-label">Groups</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="totalFiles">0</div>
            <div class="stat-label">Files</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="totalSize">0</div>
            <div class="stat-label">Total Size</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="potentialSavings">0</div>
            <div class="stat-label">Potential Savings</div>
          </div>
        </div>

        <div class="filters">
          <div class="filter-group">
            <label for="pathFilter" class="filter-label">Filter by path</label>
            <input
              type="text"
              id="pathFilter"
              class="filter-input"
              placeholder="Enter path to filter..."
              oninput="applyFilters()"
            />
          </div>
          <div class="filter-group">
            <label for="sizeFilter" class="filter-label">Filter by size</label>
            <select
              id="sizeFilter"
              onchange="applyFilters()"
              aria-label="Filter by file size"
            >
              <option value="all">All Sizes</option>
              <option value="small">Small (0-1MB)</option>
              <option value="medium">Medium (1-10MB)</option>
              <option value="large">Large (10-100MB)</option>
              <option value="xlarge">Extra Large (100MB-1GB)</option>
              <option value="xxlarge">XXL (1GB+)</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="typeFilter" class="filter-label">Filter by type</label>
            <select
              id="typeFilter"
              onchange="applyFilters()"
              aria-label="Filter by file type"
            >
              <option value="">All Types</option>
              <option value="image">Images</option>
              <option value="audio">Audio</option>
              <option value="video">Video</option>
              <option value="document">Documents</option>
              <option value="other">Other</option>
            </select>
          </div>
          <div class="filter-group auto-select-group">
            <div>
              <label for="autoSelect" class="filter-label">Auto-select</label>
              <select
                id="autoSelect"
                onchange="applyAutoSelect()"
                aria-label="Auto-select files"
              >
                <option value="none">None</option>
                <option value="allButFirst">All but first</option>
                <option value="allButLast">All but last</option>
                <option value="longestName">Longest name</option>
                <option value="shortestName">Shortest name</option>
                <option value="deepestPath">Deepest path</option>
                <option value="shallowestPath">Shallowest path</option>
                <option value="smart">Smart (AI-powered)</option>
              </select>
            </div>
            <button
              class="delete-selected delete"
              onclick="deleteSelected()"
              disabled
              id="deleteSelectedBtn"
            >
              Delete Selected
            </button>
          </div>
        </div>

        <div class="top-actions">
          <button onclick="toggleAllGroups()">Toggle All Groups</button>
          <button onclick="showBatchRename()">Batch Rename</button>
        </div>
      </div>
    </div>

    <div class="main-content">
      <div id="groups"></div>
    </div>

    <div class="footer">
      <button class="shutdown-btn" onclick="shutdown(false)">
        Shutdown Server
      </button>
      <button class="shutdown-btn delete" onclick="shutdown(true)">
        Shutdown & Delete Index
      </button>
    </div>

    <div
      class="preview-modal"
      id="previewModal"
      role="dialog"
      aria-label="File preview"
    >
      <button
        class="close-preview"
        onclick="closePreview()"
        aria-label="Close preview"
      >
        Ã—
      </button>
      <div class="preview-content" id="previewContent"></div>
    </div>
    <script>
      // Theme management
      function toggleTheme() {
        const theme =
          document.documentElement.getAttribute("data-theme") === "dark"
            ? "light"
            : "dark";
        document.documentElement.setAttribute("data-theme", theme);
        localStorage.setItem("theme", theme);
      }

      // Initialize theme
      const savedTheme = localStorage.getItem("theme") || "light";
      document.documentElement.setAttribute("data-theme", savedTheme);

      let duplicateGroups = [];
      let allGroupsExpanded = true;

      function getFileIcon(path) {
        const ext = path.toLowerCase().split(".").pop();
        const imageExts = ["jpg", "jpeg", "png", "gif", "bmp", "webp"];
        const documentExts = ["pdf", "doc", "docx", "txt", "md", "rtf"];
        const videoExts = ["mp4", "avi", "mov", "wmv", "flv", "mkv"];
        const audioExts = ["mp3", "wav", "ogg", "m4a", "flac"];

        if (imageExts.includes(ext)) return "ðŸ–¼ï¸";
        if (documentExts.includes(ext)) return "ðŸ“„";
        if (videoExts.includes(ext)) return "ðŸŽ¥";
        if (audioExts.includes(ext)) return "ðŸŽµ";
        return "ðŸ“";
      }

      function updateStats() {
        const totalGroups = duplicateGroups.length;
        const totalFiles = duplicateGroups.reduce(
          (sum, group) => sum + group.length,
          0
        );
        const totalSize = duplicateGroups.reduce((sum, group) => {
          return sum + group[0].size * group.length;
        }, 0);
        const potentialSavings = duplicateGroups.reduce((sum, group) => {
          return sum + group[0].size * (group.length - 1);
        }, 0);

        document.getElementById("totalGroups").textContent = totalGroups;
        document.getElementById("totalFiles").textContent = totalFiles;
        document.getElementById("totalSize").textContent =
          formatSize(totalSize);
        document.getElementById("potentialSavings").textContent =
          formatSize(potentialSavings);
      }

      function formatSize(bytes) {
        const units = ["B", "KB", "MB", "GB", "TB"];
        let size = bytes;
        let unitIndex = 0;

        while (size >= 1024 && unitIndex < units.length - 1) {
          size /= 1024;
          unitIndex++;
        }

        return `${size.toFixed(1)}${units[unitIndex]}`;
      }
      function toggleAllGroups() {
        allGroupsExpanded = !allGroupsExpanded;
        document.querySelectorAll(".group").forEach((group) => {
          if (allGroupsExpanded) {
            group.classList.remove("collapsed");
          } else {
            group.classList.add("collapsed");
          }
        });
      }

      function toggleGroup(groupIndex) {
        const group = document.querySelector(
          `.group[data-group-index="${groupIndex}"]`
        );
        group.classList.toggle("collapsed");
      }

      async function showBatchRename() {
        const selectedFiles = Array.from(
          document.querySelectorAll(".file-checkbox:checked")
        ).map((checkbox) => checkbox.dataset.path);

        if (selectedFiles.length === 0) {
          alert("Please select files to rename");
          return;
        }

        const pattern = prompt(
          "Enter rename pattern:\n{n} = original name\n{i} = index\n{ext} = extension"
        );
        if (!pattern) return;

        try {
          for (let i = 0; i < selectedFiles.length; i++) {
            const oldPath = selectedFiles[i];
            const oldName = oldPath.split("/").pop();
            const ext = oldName.includes(".") ? oldName.split(".").pop() : "";
            const baseName = oldName.includes(".")
              ? oldName.slice(0, -ext.length - 1)
              : oldName;

            const newName = pattern
              .replace("{n}", baseName)
              .replace("{i}", (i + 1).toString().padStart(2, "0"))
              .replace("{ext}", ext ? `.${ext}` : "");

            await fetch("/api/rename", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ oldPath, newName }),
            });
          }
          loadDuplicates();
        } catch (error) {
          alert("Failed to rename files: " + error.message);
        }
      }

      async function deleteSelected() {
        const selectedPaths = Array.from(
          document.querySelectorAll(".file-checkbox:checked")
        ).map((checkbox) => checkbox.dataset.path);

        if (
          !confirm(
            `Are you sure you want to delete ${selectedPaths.length} file(s)?`
          )
        )
          return;

        try {
          for (const path of selectedPaths) {
            await fetch("/api/delete", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ filePath: path }),
            });
          }
          loadDuplicates();
        } catch (error) {
          alert("Failed to delete files: " + error.message);
        }
      }
      async function deleteFile(path) {
        if (!confirm(`Are you sure you want to delete ${path}?`)) {
          return;
        }

        try {
          await fetch("/api/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ filePath: path }),
          });
          loadDuplicates();
        } catch (error) {
          alert("Failed to delete file: " + error.message);
        }
      }

      async function renameFile(groupIndex, fileIndex, input) {
        if (!input.value) return;

        const group = document.querySelector(
          `.group[data-group-index="${groupIndex}"]`
        );
        const file = group.querySelector(
          `.file[data-file-index="${fileIndex}"]`
        );
        const oldPath = file.querySelector(".file-checkbox").dataset.path;

        try {
          const response = await fetch("/api/rename", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ oldPath, newName: input.value }),
          });

          if (response.ok) {
            const result = await response.json();
            file.querySelector(".file-info").firstElementChild.textContent =
              result.newPath;
            file.querySelector(".file-checkbox").dataset.path = result.newPath;
            input.value = "";
            loadDuplicates(); // Reload to update all metadata
          }
        } catch (error) {
          alert("Failed to rename file: " + error.message);
        }
      }

      async function previewFile(path) {
        const modal = document.getElementById("previewModal");
        const content = document.getElementById("previewContent");
        const mimeType = getMimeType(path);
        const encodedPath = encodeURIComponent(path);
        const previewUrl = `/api/download/${encodedPath}`;

        modal.style.display = "block";
        content.innerHTML = "Loading preview...";

        try {
          if (mimeType.startsWith("image/")) {
            content.innerHTML = `<img src="${previewUrl}" class="media-preview" alt="Preview of ${path}">`;
          } else if (mimeType.startsWith("video/")) {
            content.innerHTML = `<video src="${previewUrl}" class="preview-video" controls>
              Your browser does not support video playback.
            </video>`;
          } else if (mimeType.startsWith("audio/")) {
            content.innerHTML = `<audio src="${previewUrl}" class="preview-audio" controls>
              Your browser does not support audio playback.
            </audio>`;
          } else if (mimeType === "application/pdf") {
            content.innerHTML = `<iframe src="${previewUrl}" class="preview-iframe"></iframe>`;
          } else if (mimeType.startsWith("text/")) {
            const response = await fetch(previewUrl);
            const text = await response.text();
            content.innerHTML = `<pre class="preview-text">${escapeHtml(
              text
            )}</pre>`;
          } else {
            content.innerHTML = `<div class="preview-text">
              Preview not available for this file type (${mimeType}).<br>
              <button onclick="downloadFile('${path}')">Download Instead</button>
            </div>`;
          }
        } catch (error) {
          content.innerHTML = `<div class="preview-text">Failed to load preview: ${error.message}</div>`;
        }
      }
      function getMimeType(path) {
        const ext = path.toLowerCase().split(".").pop();
        const mimeTypes = {
          // Images
          jpg: "image/jpeg",
          jpeg: "image/jpeg",
          png: "image/png",
          gif: "image/gif",
          webp: "image/webp",
          // Audio
          mp3: "audio/mpeg",
          wav: "audio/wav",
          ogg: "audio/ogg",
          mid: "audio/midi",
          midi: "audio/midi",
          // Video
          mp4: "video/mp4",
          webm: "video/webm",
          // Documents
          pdf: "application/pdf",
          txt: "text/plain",
          json: "application/json",
          html: "text/html",
          htm: "text/html",
          css: "text/css",
          js: "text/javascript",
          md: "text/markdown",
        };
        return mimeTypes[ext] || "application/octet-stream";
      }

      function escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function closePreview() {
        document.getElementById("previewModal").style.display = "none";
      }

      function downloadFile(path) {
        const encodedPath = encodeURIComponent(path);
        window.location.href = `/api/download/${encodedPath}`;
      }

      async function shutdown(deleteIndex = false) {
        if (
          !confirm(
            `Are you sure you want to shutdown the server${
              deleteIndex ? " and delete the index file" : ""
            }?`
          )
        ) {
          return;
        }

        try {
          await fetch("/api/shutdown", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ deleteIndex }),
          });
          document.body.innerHTML =
            "<h1>Server has been shut down</h1><p>You can close this window now.</p>";
        } catch (error) {
          document.body.innerHTML =
            "<h1>Server has been shut down</h1><p>You can close this window now.</p>";
        }
      }
      function applyFilters() {
        renderGroups();
      }

      function getFileSize(size) {
        const mb = size / (1024 * 1024);
        if (mb >= 1024) return "xxlarge"; // 1GB+
        if (mb >= 100) return "xlarge"; // 100MB-1GB
        if (mb >= 10) return "large"; // 10-100MB
        if (mb >= 1) return "medium"; // 1-10MB
        return "small"; // 0-1MB
      }

      function formatDate(date) {
        return new Date(date).toLocaleString();
      }

      function getFileType(path) {
        const ext = path.toLowerCase().split(".").pop();
        const imageExts = ["jpg", "jpeg", "png", "gif", "bmp", "webp"];
        const documentExts = ["pdf", "doc", "docx", "txt", "md", "rtf"];
        const videoExts = ["mp4", "avi", "mov", "wmv", "flv", "mkv"];
        const audioExts = ["mp3", "wav", "ogg", "m4a", "flac"];

        if (imageExts.includes(ext)) return "image";
        if (documentExts.includes(ext)) return "document";
        if (videoExts.includes(ext)) return "video";
        if (audioExts.includes(ext)) return "audio";
        return "other";
      }

      function renderGroups() {
        const pathFilter = document
          .getElementById("pathFilter")
          .value.toLowerCase();
        const sizeFilter = document.getElementById("sizeFilter").value;
        const typeFilter = document.getElementById("typeFilter").value;

        const filteredGroups = duplicateGroups.filter((group) => {
          // Apply size filter
          if (sizeFilter !== "all") {
            const sizeCategory = getFileSize(group[0].size);
            if (sizeFilter !== sizeCategory) return false;
          }

          // Apply path and type filters
          return group.some((file) => {
            const matchesPath = file.path.toLowerCase().includes(pathFilter);
            const matchesType =
              !typeFilter || getFileType(file.path) === typeFilter;
            return matchesPath && matchesType;
          });
        });

        const container = document.getElementById("groups");
        container.innerHTML = filteredGroups
          .map((group, groupIndex) => {
            const hash = group[0].hash;
            return `
          <div class="group" data-group-index="${groupIndex}">
            <div class="group-header" onclick="toggleGroup(${groupIndex})">
              <span class="collapse-indicator">â–¼</span>
              <h3>Group ${groupIndex + 1} - ${group[0].formattedSize} - ${
              hash ? hash.slice(0, 8) : "calculating..."
            }</h3>
              <label>
                <input type="checkbox" 
                       onchange="toggleGroupSelection(${groupIndex}, this.checked); event.stopPropagation();" 
                       class="group-checkbox"
                       aria-label="Select all files in group ${groupIndex + 1}">
                Select All
              </label>
            </div>
            <div class="group-content">
              ${group
                .map((file, fileIndex) => {
                  // Properly escape the file path for both HTML and JavaScript
                  const escapedPath = file.path
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
                  const jsEscapedPath = file.path.replace(/['\\]/g, "\\$&");

                  return `
                <div class="file" data-file-index="${fileIndex}">
                  <div class="file-select">
                    <input type="checkbox" 
                           class="file-checkbox" 
                           data-path="${escapedPath}"
                           onchange="updateDeleteButton()"
                           aria-label="Select ${escapedPath}">
                  </div>
                  <div class="file-info">
                    <div class="file-icon">${getFileIcon(file.path)}</div>
                    <div class="file-details">
                      <div class="file-path">${escapedPath}</div>
                      <div class="file-meta">
                        <span>Size: ${file.formattedSize}</span>
                        <span>Modified: ${formatDate(file.modified)}</span>
                        <span>Created: ${formatDate(file.created)}</span>
                      </div>
                    </div>
                  </div>
                  <div class="actions">
                    <div class="rename-container">
                      <input type="text" 
                             placeholder="New name" 
                             onkeyup="if(event.key==='Enter') renameFile(${groupIndex}, ${fileIndex}, this)"
                             aria-label="New name for ${escapedPath}">
                      <button class="rename-btn" 
                              onclick="renameFile(${groupIndex}, ${fileIndex}, this.previousElementSibling)">
                        Rename
                      </button>
                    </div>
                    <button class="preview-btn" onclick="previewFile('${jsEscapedPath}')" aria-label="Preview ${escapedPath}">Preview</button>
                    <button class="download" onclick="downloadFile('${jsEscapedPath}')" aria-label="Download ${escapedPath}">Download</button>
                    <button class="delete individual-delete" onclick="deleteFile('${jsEscapedPath}')" aria-label="Delete ${escapedPath}">Delete</button>
                  </div>
                </div>
              `;
                })
                .join("")}
            </div>
          </div>
        `;
          })
          .join("");

        updateDeleteButton();
      }
      function updateDeleteButton() {
        const selectedCount = document.querySelectorAll(
          ".file-checkbox:checked"
        ).length;
        const deleteBtn = document.getElementById("deleteSelectedBtn");
        deleteBtn.disabled = selectedCount === 0;
        deleteBtn.textContent = `Delete Selected (${selectedCount})`;
      }

      function toggleGroupSelection(groupIndex, checked) {
        const group = document.querySelector(
          `.group[data-group-index="${groupIndex}"]`
        );
        group.querySelectorAll(".file-checkbox").forEach((checkbox) => {
          checkbox.checked = checked;
        });
        updateDeleteButton();
      }

      let pipeline;
      let modelLoading = false;

      async function initializeModel() {
        if (pipeline || modelLoading) return;
        modelLoading = true;

        try {
          pipeline = await window.pipeline(
            "feature-extraction",
            "Xenova/all-MiniLM-L6-v2"
          );
        } finally {
          modelLoading = false;
        }
      }

      // Scoring criteria for smart selection
      function getSmartScore(filePath, metadata) {
        // Initialize with base score
        let score = 0;
        const path = filePath.toLowerCase();

        // Scoring criteria:
        // 1. Prefer keeping files in common user directories
        if (path.includes("/documents/")) score += 2;
        if (path.includes("/desktop/")) score += 1;
        if (path.includes("/downloads/")) score -= 1;
        if (path.includes("/temp/") || path.includes("/tmp/")) score -= 2;

        // 2. Prefer keeping recently modified files
        const modifiedDate = new Date(metadata.modified);
        const now = new Date();
        const daysSinceModified = (now - modifiedDate) / (1000 * 60 * 60 * 24);
        score += Math.max(-3, Math.min(3, 2 - daysSinceModified / 30)); // Scale based on months

        // 3. Prefer keeping files with more descriptive names
        const fileName = path.split("/").pop();
        if (fileName.length > 20) score += 1; // More descriptive names tend to be longer
        if (/^[a-zA-Z]/.test(fileName)) score += 0.5; // Prefer names that start with letters
        if (/\d{8,}/.test(fileName)) score -= 0.5; // Penalize names with long number sequences

        // 4. File organization signals
        if (path.split("/").length > 4) score += 1; // Organized in deeper directory structure
        if (/^[\d-_]+$/.test(fileName.split(".")[0])) score -= 1; // Penalize pure numeric/symbol names

        return score;
      }

      async function applySmartSelection(files) {
        await initializeModel();
        if (!pipeline) {
          console.error("Failed to load AI model");
          return null;
        }

        // Get embeddings for all file paths
        const fileData = await Promise.all(
          files.map(async (file) => {
            const path = file.querySelector(".file-path").textContent;
            const metadata = {
              modified: file
                .querySelector(".file-meta")
                .textContent.match(/Modified: (.*?)(?=\s|$)/)[1],
            };

            // Get embedding for the file path
            const embedding = await pipeline(path, {
              pooling: "mean",
              normalize: true,
            });

            // Combine embedding with traditional heuristics
            const smartScore = getSmartScore(path, metadata);

            return {
              file,
              path,
              embedding: embedding.data,
              smartScore,
            };
          })
        );

        // Calculate similarity scores between files
        for (let i = 0; i < fileData.length; i++) {
          let similarityScore = 0;
          for (let j = 0; j < fileData.length; j++) {
            if (i !== j) {
              // Calculate cosine similarity between embeddings
              const similarity = fileData[i].embedding.reduce(
                (sum, val, idx) => sum + val * fileData[j].embedding[idx],
                0
              );
              similarityScore += similarity;
            }
          }
          fileData[i].similarityScore = similarityScore / (fileData.length - 1);
        }

        // Make final decision based on both smart score and similarity
        fileData.forEach((data) => {
          data.finalScore = data.smartScore + data.similarityScore * 2;
        });

        // Sort by final score and mark all but the highest scoring file for deletion
        const sortedFiles = fileData.sort(
          (a, b) => b.finalScore - a.finalScore
        );
        return sortedFiles.slice(1).map((data) => data.file);
      }

      async function applyAutoSelect() {
        const mode = document.getElementById("autoSelect").value;
        const groups = document.querySelectorAll(".group");

        for (const group of groups) {
          const files = Array.from(group.querySelectorAll(".file"));
          const checkboxes = files.map((f) =>
            f.querySelector(".file-checkbox")
          );

          // Uncheck all first
          checkboxes.forEach((cb) => (cb.checked = false));

          switch (mode) {
            case "allButFirst":
              checkboxes.slice(1).forEach((cb) => (cb.checked = true));
              break;
            case "allButLast":
              checkboxes.slice(0, -1).forEach((cb) => (cb.checked = true));
              break;
            case "longestName":
              const longest = files.reduce((a, b) =>
                a.querySelector(".file-path").textContent.length >
                b.querySelector(".file-path").textContent.length
                  ? a
                  : b
              );
              longest.querySelector(".file-checkbox").checked = true;
              break;
            case "shortestName":
              const shortest = files.reduce((a, b) =>
                a.querySelector(".file-path").textContent.length <
                b.querySelector(".file-path").textContent.length
                  ? a
                  : b
              );
              shortest.querySelector(".file-checkbox").checked = true;
              break;
            case "deepestPath":
              const deepest = files.reduce((a, b) =>
                (a.querySelector(".file-path").textContent.match(/\//g) || [])
                  .length >
                (b.querySelector(".file-path").textContent.match(/\//g) || [])
                  .length
                  ? a
                  : b
              );
              deepest.querySelector(".file-checkbox").checked = true;
              break;
            case "shallowestPath":
              const shallowest = files.reduce((a, b) =>
                (a.querySelector(".file-path").textContent.match(/\//g) || [])
                  .length <
                (b.querySelector(".file-path").textContent.match(/\//g) || [])
                  .length
                  ? a
                  : b
              );
              shallowest.querySelector(".file-checkbox").checked = true;
              break;
            case "smart":
              // Show loading state
              const loadingIndicator = document.createElement("div");
              loadingIndicator.textContent = "AI is analyzing files...";
              loadingIndicator.style.position = "fixed";
              loadingIndicator.style.top = "50%";
              loadingIndicator.style.left = "50%";
              loadingIndicator.style.transform = "translate(-50%, -50%)";
              loadingIndicator.style.padding = "1rem";
              loadingIndicator.style.background = "var(--bg-secondary)";
              loadingIndicator.style.border = "1px solid var(--border-color)";
              loadingIndicator.style.borderRadius = "4px";
              loadingIndicator.style.zIndex = "1000";
              document.body.appendChild(loadingIndicator);

              try {
                const filesToDelete = await applySmartSelection(files);
                if (filesToDelete) {
                  filesToDelete.forEach((file) => {
                    file.querySelector(".file-checkbox").checked = true;
                  });
                }
              } catch (error) {
                console.error("Smart selection failed:", error);
                alert(
                  "Smart selection failed. Falling back to manual selection."
                );
              } finally {
                document.body.removeChild(loadingIndicator);
              }
              break;
          }
        }

        updateDeleteButton();
      }
      async function loadDuplicates() {
        const response = await fetch("/api/duplicates");
        duplicateGroups = await response.json();
        renderGroups();
        updateStats();
      }

      async function loadScanInfo() {
        try {
          const response = await fetch("/api/scan-info");
          const info = await response.json();

          if (info) {
            const scanInfo = document.getElementById("scanInfo");
            scanInfo.classList.add("show");
            scanInfo.innerHTML = `
        <div class="scan-info-item">
          Base Directory: <span class="scan-info-value">${
            info.baseDirectory
          }</span>
        </div>
        <div class="scan-info-item">
          Scan Time: <span class="scan-info-value">${formatDuration(
            info.endTime - info.startTime
          )}</span>
        </div>
        <div class="scan-info-item">
          Files Scanned: <span class="scan-info-value">${
            info.filesScanned
          }</span>
        </div>
        <div class="scan-info-item">
          Groups Found: <span class="scan-info-value">${info.groupsFound}</span>
        </div>
      `;
          }
        } catch (error) {
          console.error("Failed to load scan info:", error);
        }
      }

      function formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);

        if (hours > 0) {
          return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
        } else if (minutes > 0) {
          return `${minutes}m ${seconds % 60}s`;
        } else {
          return `${seconds}s`;
        }
      }

      function toggleHeader() {
        const headerContent = document.querySelector(".header-content");
        headerContent.classList.toggle("collapsed");
        const btn = document.querySelector(".collapse-header-btn");
        btn.textContent = headerContent.classList.contains("collapsed")
          ? "â–²"
          : "â–¼";
      }

      // Initialize
      loadDuplicates();
      loadScanInfo();

      // Close preview modal when clicking outside
      document
        .getElementById("previewModal")
        .addEventListener("click", function (e) {
          if (e.target === this) closePreview();
        });

      // Handle Escape key to close preview
      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape") closePreview();
      });
    </script>
  </body>
</html>
